//
//	M5StickC Plus postscript library
//		function module
//		(c) 2022	1YEN Toru
//


#include	<M5StickCPlus.h>
#include	<m5cp_ps.h>


#ifdef		ARDUINO_M5Stick_C_PLUS
#else	// ERROR:
#error	"This architecture is not supported."
#endif


const	char	*rtc_week[]=
{
	// English short
	"Sun",	"Mon",	"Tue",	"Wed",	"Thu",	"Fri",	"Sat",
	// +7: Japanese S-JIS
	"\x93\xfa",	"\x8c\x8e",	"\x89\xce",	"\x90\x85",
				"\x96\xd8",	"\x8b\xe0",	"\x93\x79",
};
const	uint8	icon_bat[]=
{
	// file: icon_pix8_bat_ful_20.xpic (15 x 20 dot)
	15,20,
	// 8 bit pixel: 3R-3G-2B
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x00,0x00,0x00,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0x00,0xff,0xff,0xff,0x00,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0xbe,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0x1c,0xbe,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc
};
const	uint8	icon_acp[]=
{
	// file: icon_pix8_acp_20.xpic (15 x 20 dot)
	15,20,
	// 8 bit pixel: 3R-3G-2B
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x93,0x93,0x93,0x93,0x93,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x93,0x93,0x4a,0x4a,0x4a,0x4a,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x93,0x93,0x4a,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x00,0x03,0x93,0x93,0x03,0x03,0x00,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0x00,0x03,0x93,0x93,0x03,0x03,0x03,0x03,0x00,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0x00,0x93,0x93,0x03,0x03,0x03,0x03,0x03,0x00,0xfc,0xfc,0xfc,
	0xfc,0xfc,0x00,0x03,0x93,0x03,0x03,0x93,0x03,0x03,0x03,0x03,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x03,0x03,0x03,0x93,0x93,0x93,0x03,0x03,0x02,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x03,0x03,0x03,0x03,0x93,0x03,0x03,0x03,0x02,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x02,0x02,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x03,0x03,0x02,0x02,0x02,0x02,0x02,0x02,0x02,0x00,0xfc,0xfc,
	0xfc,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x93,0x93,0xfc,0xfc,0xfc,0x93,0x93,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0x93,0x4a,0xfc,0xfc,0xfc,0xfc,
	0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc,0xfc
};


uint8	rtc_reg[rtc_SIZ_CNT];


char	*strnum3c (
int		num,
char	*str)
{
	// insert comma every 3 digits
	//	num: number to insert comma
	//	str: destination C string buffer, can be NULL
	int		len;
	int		cnt;
	int		sptr;
	int		dptr;
	char	buf[16];
	static	char	str_buf[16];
	const	int		chr_cma=',';

	// parameter
	if (str==NULL)
		str=str_buf;

	// negative number
	dptr=0;
	if (num<0)
	{
		str[ dptr++ ]='-';
		num=-num;
	}

	// number to string
	sprintf (buf,"%d",num);
	len=strlen (buf);
	cnt=(len - 1)%3 + 1;

	// insert comma
	sptr=0;
	while (sptr<len)
	{
		str[ dptr++ ]=buf[ sptr++ ];
		cnt--;
		if (cnt==0 && sptr<len)
		{
			str[ dptr++ ]=chr_cma;
			cnt=3;
		}
	}
	str[dptr]='\0';

	return (str);
}


int		i2c1_read (
int		slv_adr,
int		cmnd,
int		rcnt,
uint8	*rbuf)
{
	// i2c read protocol; Wire1
	// cmnd: command
	// rcnt: receive data count
	// rbuf: receive data buffer (can be NULL)
	// return: received 1st byte / M5psErrBadParam / M5psErrI2cRecv
	int		errcod;
	int		idx;
	int		dat;

	// parameter
	if (slv_adr<0x08)
		return (M5psErrBadParam);

	// register address
	Wire1.beginTransmission (slv_adr);
	Wire1.write (cmnd);
	errcod=Wire1.endTransmission (false);	// do not send stop condition
	if (errcod!=0)
	{
		// ERROR:
		return (M5psErrI2cRecv);
	}

	// receive data
	dat=-1;
	Wire1.requestFrom (slv_adr, rcnt);
	for (idx=0; idx<rcnt; idx++)
	{
		dat=Wire1.read ();
		if (rbuf==NULL)
			break;
		else
			rbuf[idx]=dat&0xff;
	}

	// discard remaining
	while (Wire1.available ())
		Wire1.read ();

	return ((rbuf==NULL)? dat: rbuf[0]);
}

int		i2c1_write (
int		slv_adr,
int		cmnd,
int		scnt,
uint8	*sbuf)
{
	// i2c write protocol; Wire1
	// cmnd: command
	// scnt: send data count
	// sbuf: send data buffer
	// return: M5psErrNo / M5psErrBadParam / M5psErrI2cRecv
	int		errcod;
	int		idx;

	// parameter
	if (slv_adr<0x08 || (scnt>0 && sbuf==NULL))
		return (M5psErrBadParam);

	// register address
	Wire1.beginTransmission (slv_adr);
	Wire1.write (cmnd);
	// data
	for (idx=0; idx<scnt; idx++)
		Wire1.write (sbuf[idx]);
	errcod=Wire1.endTransmission ();
	if (errcod!=0)
	{
		// ERROR:
		return (M5psErrI2cSend);
	}

	return (M5psErrNo);
}

int		i2c1_write (
int		slv_adr,
int		cmnd,
uint8	sdat)
{
	// i2c write byte protocol; Wire1
	// cmnd: command
	// sdat: send data
	// return: i2c1_write()

	return (i2c1_write (slv_adr,cmnd,1,&sdat));
}


bool	axp_is_power_avail (void)
{
	// is power (VBUS or ACIN) available
	uint8	dat;

	dat=i2c1_read (i2c_AXP192,axp_REG_PWR_STAT,1,NULL);

	return ((dat&0x54)? true: false);
}

int		axp_get_bat_level (
int		full_scale)
{
	// get battery level
	// return: 0~full_scale / M5psErrBadParam / M5psErrNotRdy
	float	lv_bat;

	// parameter
	if (full_scale<=0)
	{
		// ERROR: ignore
		return (M5psErrBadParam);
	}

	// level
	lv_bat=M5.Axp.GetBatVoltage ();
	if (lv_bat==0.)
	{
		// WARNING: AXP192 was not ready
		return (M5psErrNotRdy);
	}
	lv_bat=(lv_bat - bat_LOW0)/(bat_HI100 - bat_LOW0);
	lv_bat=(lv_bat<0.)? 0.: (lv_bat>1.)? 1.: lv_bat;

	return (full_scale*lv_bat);
}


void	rtc_get_date_time (
uint8	*rbuf)
{
	// get date & time from BM8563(RTC)
	int		idx;

	// the rtc counter must be read in one bus transaction.
	i2c1_read (i2c_BM8563,rtc_REG_CNT,rtc_SIZ_CNT,rbuf);
}

void	rtc_set_date_time (
uint8	*wbuf)
{
	// set date & time to BM8563(RTC)

	// the rtc counter must be written in one bus transaction.
	i2c1_write (i2c_BM8563,rtc_REG_CNT,rtc_SIZ_CNT,wbuf);
}

int		rtc_day_of_week (
int		yr,
int		mo,
int		dy)
{
	// calculate day of week
	//	yr: century year
	//	mo: month (1~12)
	//	dy: day of month (1~31)
	// return: day of week (Sun0~Sat6)
	int		yy;
	int		cc;
	int		rr;
	int		hh;

	if (mo<=2)
	{
		yr--;
		mo += 12;
	}
	cc=yr/100;
	yy=yr - cc*100;
	rr=-2*cc + cc/4;
	hh=dy + 26*(mo + 1)/10 + yy + yy/4 + rr;
	hh=(hh + 7 - 1)%7;

	return (hh);
}

int		bcd2dec (
int		bcd)
{
	// BCD to decimal conversion
	// return: decimal
	int		idx;
	int		dec;
	int		bs;

	dec=0;
	bs=1;
	for (idx=0; idx<2*sizeof (int) && bcd>0; idx++)
	{
		dec += (bcd&0x0f)*bs;
		bs *= 10;
		bcd >>= 4;
	}

	return (dec);
}

int		dec2bcd (
int		dec)
{
	// decimal to BCD conversion
	// return: BCD
	int		idx;
	int		bcd;
	int		bs;

	bcd=0;
	bs=1;
	for (idx=0; idx<2*sizeof (int) && dec>0; idx++)
	{
		bcd += (dec%10)*bs;
		bs <<= 4;
		dec /= 10;
	}

	return (bcd);
}


void	tft_draw_icon (
const	uint8	*icn,
int		pix_tp)
{
	// draw icon
	//	icn: icon bit map data
	//		uint8 { <sizh>,<sizv>, <pixel_r3_g3_b2>, ... }
	//	pix_tp: transparent 8 bit pixel value
	//	location: tft_locate (lx,ly)
	//	size: tft_font_size (sx,sy)
	int		ix;
	int		iy;
	int		x1;
	int		y1;
	int		x2;
	int		y2;
	int		sizh;
	int		sizv;
	int		sx;
	int		sy;
	int		ir;
	int		ig;
	int		ib;
	uint8	pix8;
	uint16	pix16;

	// parameter
	if (icn==NULL)
	{
		// WARNING: ignore
		return;
	}
	sizh=icn[0];
	sizv=icn[1];
	if (sizh==0 || sizv==0)
	{
		// WARNING: ignore
		return;
	}
	tft_fwid=M5.Lcd.width ();
	tft_fhei=M5.Lcd.height ();

	// size
	sx=tft_prn_sx;
	sy=tft_prn_sy;
	if (sx<sizh)
		sx=sizh;
	if (sy<sizv)
		sy=sizv;

	// draw icon
	for (iy=0; iy<sizv; iy++)
	{
		y1=tft_prn_ly + iy*sy/sizv;
		y2=tft_prn_ly + (iy + 1)*sy/sizv - 1;
		if (y1>tft_fhei - 1)
			break;
		else if (y2>tft_fhei - 1)
			y2=tft_fhei - 1;
		for (ix=0; ix<sizh; ix++)
		{
			x1=tft_prn_lx + ix*sx/sizh;
			x2=tft_prn_lx + (ix + 1)*sx/sizh - 1;
			if (x1>tft_fwid - 1)
				break;
			else if (x2>tft_fwid - 1)
				x2=tft_fwid - 1;
			pix8=icn[2 + iy*sizh + ix];
			// draw pixel
			if (pix8!=pix_tp)
			{
				// pixel
				ir=(pix8>>5)&0x07;
				ig=(pix8>>2)&0x07;
				ib=(pix8>>0)&0x03;
				ir=(((ir<<3) + ir)>>1)&0x1f;
				ig=(((ig<<3) + ig)>>0)&0x3f;
				ib=(((((ib<<2) + ib)<<2) + ib)>>1)&0x1f;
				pix16=(ir<<11) + (ig<<5) + ib;
				M5.Lcd.fillRect (x1,y1,x2 - x1 + 1,y2 - y1 + 1, pix16);
			}
		}
	}

	// update cursor
	tft_prn_lx += sx;
}

void	tft_draw_bat (void)
{
	// draw battery indicator
	//	location: tft_locate (lx,ly)
	//	size: tft_font_size (sx,sy)
	// return: battery level (0~1000) / VBUS present (-1000)
	int		px;
	int		py;
	int		bat_lev;
	const	uint8	*icn;
	uint16	pc;
	uint32	msec_start;

	// battery level
	bat_lev=axp_get_bat_level ();
	if (bat_lev<0)
	{
		// WARNING: AXP192 was not ready
		// wait AXP192's stabilization
		msec_start=millis ();
		while (M5.Axp.GetBatVoltage ()==0. && millis () - msec_start<500)
			delay (50);
		bat_lev=axp_get_bat_level ();
		if (bat_lev<0)
			bat_lev=0;
	}
	if (axp_is_power_avail ())
	{
		// battery charging
		icn=icon_acp;
		bat_lev=bat_lev - 101;
	}
	else
	{
		// battery discharging
		icn=icon_bat;
	}

	// draw
	px=tft_prn_lx;
	py=tft_prn_ly;
	tft_draw_icon (icn, icn[2]);
	if (bat_lev<0)
	{
		// battery charging
		bat_lev=-(bat_lev + 1);
		M5.Lcd.drawFastVLine (px,py, icn[1]*bat_lev/100, RED);
	}
	else
	{
		// battery discharging
		pc=tft_rgb2pix (63*(100 - bat_lev)/100,0,0);
		M5.Lcd.fillRect (
			px + 3*tft_prn_sx/icn[0],
			py + 4*tft_prn_sy/icn[1],
			12*tft_prn_sx/icn[0] - 3*tft_prn_sx/icn[0],
			(18*tft_prn_sy/icn[1] - 4*tft_prn_sy/icn[1])*(100 - bat_lev)/100,
			pc);
	}
}

void	tft_draw_title (
const	char	*ttl,
int		opt)
{
	// draw title
	//	opt: 0b0000_000B
	//		B=1: do not show battery indicator

	tft_fwid=M5.Lcd.width ();
	tft_fhei=M5.Lcd.height ();
	M5.Lcd.fillRect (0,0, tft_fwid,20, BLUE);
	tft_locate (0,3);
	tft_font_size (15,15);
	tft_color (WHITE,WHITE);
	tft_kprint (ttl);

	// battery indicator
	if (!(opt&0x01))
	{
		tft_locate (tft_fwid - 15,0);
		tft_font_size (icon_bat[0],icon_bat[1]);
		tft_draw_bat ();
	}
}
